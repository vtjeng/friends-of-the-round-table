#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <random>
#include <chrono>
#include <tuple>
#include <cstring>

using namespace std;

// Helper function: returns all friend pairs in a seating arrangement (circular table)
set<pair<int, int>> all_friend_pairs(const vector<int>& seating) {
    set<pair<int, int>> friends;
    int n = seating.size();
    for (int i = 0; i < n; ++i) {
        int a = seating[i];
        int b = seating[(i + 1) % n];
        if (a > b) swap(a, b);
        friends.insert({a, b});
    }
    return friends;
}

// Helper: sorted pair for positions i and j
pair<int, int> get_pair(const vector<int>& seating, int i, int j) {
    int n = seating.size();
    int a = seating[(i + n) % n];
    int b = seating[(j + n) % n];
    if (a > b) swap(a, b);
    return {a, b};
}

// Returns new friend pairs generated by swap (i, j)
vector<pair<int, int>> new_friend_pairs(const vector<int>& seating, const set<pair<int, int>>& existing, pair<int, int> swap) {
    int i = swap.first, j = swap.second;
    vector<pair<int, int>> candidates = {
        get_pair(seating, i, j - 1),
        get_pair(seating, i, j + 1),
        get_pair(seating, j, i - 1),
        get_pair(seating, j, i + 1)
    };
    vector<pair<int, int>> result;
    for (auto& p : candidates) {
        if (p.first != p.second && existing.count(p) == 0) {
            result.push_back(p);
        }
    }
    return result;
}

int num_new_friend_pairs(const vector<int>& seating, const set<pair<int, int>>& existing, pair<int, int> swap) {
    return new_friend_pairs(seating, existing, swap).size();
}

struct GreedySwapper {
    vector<int> seating;
    set<pair<int, int>> existing;
    vector<pair<int, int>> swaps;
    int n;
    vector<pair<int, int>> all_possible_swaps;
    mt19937 rng;

    GreedySwapper(int table_size, mt19937& rng_ref) : seating(table_size), rng(rng_ref) {
        n = table_size;
        for (int i = 0; i < n; ++i) seating[i] = i;
        existing = all_friend_pairs(seating);
        // Generate all possible swaps
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                all_possible_swaps.emplace_back(i, j);
            }
        }
        shuffle(all_possible_swaps.begin(), all_possible_swaps.end(), rng);
    }

    pair<int, int> generate_swap() {
        vector<pair<int, int>> max_swaps;
        int max_new_friends = 1;
        for (auto& swap : all_possible_swaps) {
            int num_new = num_new_friend_pairs(seating, existing, swap);
            if (num_new == max_new_friends) {
                max_swaps.push_back(swap);
            } else if (num_new > max_new_friends) {
                max_new_friends = num_new;
                max_swaps = {swap};
                if (num_new == 4) break;
            }
        }
        uniform_int_distribution<int> dist(0, max_swaps.size() - 1);
        return max_swaps[dist(rng)];
    }

    void do_swap(pair<int, int> swap) {
        int i = swap.first, j = swap.second;
        vector<pair<int, int>> nfp = new_friend_pairs(seating, existing, swap);
        swap_values(seating[i], seating[j]);
        for (auto& p : nfp) existing.insert(p);
        swaps.push_back(swap);
    }

    bool is_everyone_friends() const {
        return existing.size() == static_cast<size_t>((n * (n - 1)) / 2);
    }

    int num_swaps() const { return swaps.size(); }

    static void swap_values(int& a, int& b) {
        int t = a; a = b; b = t;
    }
};

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cerr << "Usage: " << argv[0] << " <table_size> [--num-trials N]\n";
        return 1;
    }
    int table_size = atoi(argv[1]);
    int num_trials = 10000;
    for (int i = 2; i < argc; ++i) {
        if (strcmp(argv[i], "--num-trials") == 0 && i + 1 < argc) {
            num_trials = atoi(argv[++i]);
        }
    }
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    int best_swaps = table_size * (table_size - 1) / 2;
    vector<pair<int, int>> best_sequence;
    for (int t = 0; t < num_trials; ++t) {
        GreedySwapper swapper(table_size, rng);
        while (!swapper.is_everyone_friends() && swapper.num_swaps() < best_swaps) {
            auto s = swapper.generate_swap();
            swapper.do_swap(s);
        }
        if (swapper.is_everyone_friends() && swapper.num_swaps() <= best_swaps) {
            best_swaps = swapper.num_swaps();
            best_sequence = swapper.swaps;
        }
    }
    cout << "Best number of swaps: " << best_swaps << "\n";
    cout << "Swap sequence: ";
    for (auto& s : best_sequence) {
        cout << "(" << s.first << "," << s.second << ") ";
    }
    cout << endl;
    return 0;
}
